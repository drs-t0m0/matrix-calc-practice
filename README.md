# 行列計算練習


## メモリ = 主記憶装置

int a = 4
↓
メモリに a = 4 が格納される
X番地(アドレス)が振られる
X ← メモリのサイズ

int x[3] = {1, 2, 3}
それぞれの要素がメモリ番地に格納される

配列は必ずメモリ番地が連続
配列以外はメモリ番地が連続である保証はない

じゃあ x[2][2] はどのように格納されるのか

x[0][0]
x[0][1]
x[1][0]
x[1][1]

と

int a
int &a

C言語はクラスとか実体を送ることが出来ない(≒参照型)

配列を関数にパラメータで送るとは
先頭


int i: 4byte 整数
double: 8byte 浮動小数点
float: 4byte 浮動小数点
bool : 1bit(T/F)

int * p
double * p
bool * p

ポインタに方がある理由
コンパイラが次の値番地を識別するため型必要

コンパイラ = マシン語への翻訳
実行はしないので、実行時のオーバーフローのチェックなどは当然しない

実行時のエラーも色々あり、ゼロ割りなどはCPUとかエラーを上げる
OSが上記エラーを救って、標準出力を実施してる

Haswell Processor
core i7 第4世代



2次元配列で行列積
↓
行列積を1次元の配列でやる
N * i + j


try
doubleだと8ずつずれる

配列 ポイント

配列は必ずメモリ番地が連続
先頭のポインタさえ分かれば、


```
次回: 2/6 15:00 - 17:00

・宿題
2次元配列の行列積を1次元配列で計算する
```


---
Q
数学的知識はどれだけ必要？
->行列積、内積、線形台数
高校数学(IIIC)

メモリ管理で言うと

```c
for (int i = 0; i < N * N; i++) {
    matrix[i] = i + 1;
}
```

より

```c
matrix3[i * N + j] = sum;
```

の考えが大事

iとjを逆にしても問題ない(あとで試す)

あくまでも

メモリ/HD
random accessは遅い!
連続したデータを読むのと比較すると
1/2、遅い時は1/10ほどになる。

連続したデータを読むようにプログラムを書く!

malloc: 連続したメモリを確保する()
calloc:
realloc:

malloc: 後で調べる!


宿題

■時間を色々測る
どういう関数がどのくらい掛かるのか。
関数:
1. malloc確保 (3個の配列)
2. createMatrix
3. 行列積の計算

それぞれの秒数を3,4行で出力
それぞれの配列のサイズを変更することによって秒数がどのように変化するか(比例する?)
サイズは3000、4000とかいい感じのサイズ

shellでサイズを渡し、c言語 mainの引数で値を取得

■＋α
random accessを計測(createMatrixの2重ループに変更し、ループを入れ替えて、時間を計測)

gcc -O2 main.c
-> 最適化オプション有効
O2の有無で差が出るか

```
次回: 2/20 15:00 - 17:00

・宿題

■時間を色々測る
どういう関数がどのくらい掛かるのか。
関数:
1. malloc確保 (3個の配列)
2. createMatrix
3. 行列積の計算

それぞれの秒数を3,4行で出力
それぞれの配列のサイズを変更することによって秒数がどのように変化するか(比例する?)
サイズは3000、4000とかいい感じのサイズ

shellでサイズを渡し、c言語 mainの引数で値を取得

■＋α
random accessを計測(createMatrixの2重ループに変更し、ループを入れ替えて、時間を計測)

gcc -O2 main.c
-> 最適化オプション有効
O2の有無で差が出るか
```


----

gcc main.c -O0

コンパイルの最適化を有効にするかどうかのオプション
最適化とは？
-O0: シンプルに翻訳
-O1,-O2,-O3: コンパイラがいい感じに最適化する

スレッド並列化
OpenMP

```
宿題

上記を使ってCreateMatrixを並列化する
calculateMatrixをコメントアウト
Nを5000とか10000にする(もっと大きいのもやってみる)

gcc main.c -fopenmp -O3


CalculateMatrixを並列化する
jを並列化する
スレッドの確認
速度を確認

ポイント
変数やスレッドをprintfで確認する
```
